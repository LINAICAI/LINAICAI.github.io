<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>皈依</title>
  
  <subtitle>为伊消得人憔悴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linaicai.github.io/"/>
  <updated>2017-07-24T16:42:01.000Z</updated>
  <id>https://linaicai.github.io/</id>
  
  <author>
    <name>皈依</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>属性和实例变量</title>
    <link href="https://linaicai.github.io/2017/05/20/%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/"/>
    <id>https://linaicai.github.io/2017/05/20/属性和实例变量/</id>
    <published>2017-05-20T11:43:03.000Z</published>
    <updated>2017-07-24T16:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我们都知道属性的声明如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">objectivec</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span> , <span class="keyword">copy</span>)<span class="built_in">NSString</span> *userName;</span><br></pre></td></tr></table></figure></div><p>并且自动合成的实例变量是_userName;</p><p>那么两者的区别和联系:<br>由于某些安全原因，OC的属性属于类的封装，属性拥有读写方法，同时也可以用点语法来读写，并且我们可以重写它的读写方法，是一个类对外部访问的接口，而实例变量是由属性生成的内在的实质，真正在内存中存在的是实例变量，属性是它的外部读写接口，只不过它经过了封装。<br><a id="more"></a><br>需要注意的是读写属性和实例变量的时候需要遵循一些规则(推荐做法)：</p><ul><li>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">objectivec</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.userName = <span class="string">@"用户名"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"用户名:%@"</span>,_userName);</span><br></pre></td></tr></table></figure></div><ul><li>在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">objectivec</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithUserName:(<span class="built_in">NSString</span> *)userName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _userName = [userName <span class="keyword">copy</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"userName:%@"</span>,_userName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    _userName = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>有时候使用懒加载初始化技术配置数据，这种情况下需要通过属性来读取数据。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sqf</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///例如定义了以下来懒加载的Getter方法</span></span><br><span class="line">- (NSString *)userName&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">_userName</span>) &#123;</span><br><span class="line">        <span class="variable">_userName</span> = @<span class="string">"匿名用户"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_userName</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">objectivec</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///则推荐使用属性来读取</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"用户名:%@"</span>,<span class="keyword">self</span>.userName);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道属性的声明如下&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt; , &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *userName;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并且自动合成的实例变量是_userName;&lt;/p&gt;
&lt;p&gt;那么两者的区别和联系:&lt;br&gt;由于某些安全原因，OC的属性属于类的封装，属性拥有读写方法，同时也可以用点语法来读写，并且我们可以重写它的读写方法，是一个类对外部访问的接口，而实例变量是由属性生成的内在的实质，真正在内存中存在的是实例变量，属性是它的外部读写接口，只不过它经过了封装。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://linaicai.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://linaicai.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo升级记</title>
    <link href="https://linaicai.github.io/2017/03/05/Hexo%E5%8D%87%E7%BA%A7%E8%AE%B0/"/>
    <id>https://linaicai.github.io/2017/03/05/Hexo升级记/</id>
    <published>2017-03-05T08:30:20.000Z</published>
    <updated>2017-03-05T10:07:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>某天忽然心血来潮，看了一下两年前搭建的Hexo博客，发现文章经久没有更新，再想了一下原来这一年来一直都忙着公司的项目，虽然偶尔有写心得笔记的习惯，但居然一直都没有想起更新到博客，于是git clone下来本地写，完了Hexo s发现不行了，网上一看原来Hexo升级了，然后照着官网文档重新搭建起来，下面是我的升级心得。</p><p>1、新版的Hexo生态已经逐渐完善，升级的好处还是很多，不妨迁移一下<br>2、插件库和主题库还算完善，虽然不多，但该有的都有<br>3、静态博客发布到github后，作为github上的一个repo，只有public经过编译后的文件，所以需要另外一个repo来保存你博客的源文件，主要涉及到source和themes、配置文件等，默认根目录下已经有一个.gitgnore文件，可以方便的让你提交这个git项目<br>4、评论系统默认支持duoshuo和disqus，但后者已经被墙了，具体从什么时候开始不知道。<br>5、迁移旧的的博客文章过来其实就是把source目录整个移过来就好了，但需要注意的是新版的静态资源的插入方式略有改动，插入图片使用下面的方法<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">maxima</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="symbol">%</span> asset_img <span class="built_in">example</span>.jpg This <span class="built_in">is</span> an <span class="built_in">example</span> <span class="built_in">image</span> <span class="symbol">%</span>&#125;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="HTML" scheme="https://linaicai.github.io/categories/HTML/"/>
    
    
      <category term="Hexo" scheme="https://linaicai.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>云南</title>
    <link href="https://linaicai.github.io/2017/03/05/%E4%BA%91%E5%8D%97/"/>
    <id>https://linaicai.github.io/2017/03/05/云南/</id>
    <published>2017-03-05T07:51:39.000Z</published>
    <updated>2017-07-24T16:42:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>其实我是不喜欢外出的人，但妻子就特别喜欢旅游，经不住她的软硬兼施，就选定了云南作为我们的蜜月旅游之地，虽然旅途很累，胜在提前妻子就攻略好，我负责拍摄就好了，下面是我拍的一些照片。<br><a id="more"></a><br>蓝月谷 | 真的好美，拍婚照取景的天然好地方<br><a href="/2017/03/05/云南/1.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/1.jpg" title="云南图片"></a><br><a href="/2017/03/05/云南/6.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/6.jpg" title="云南图片"></a><br><a href="/2017/03/05/云南/9.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/9.jpg" title="云南图片"></a></p><p>洱海 | 不太喜欢太多人而且略有污染<br><a href="/2017/03/05/云南/2.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/2.jpg" title="云南图片"></a></p><p>虎跳峡 | 第一次领略到祖国美好山河的险峻<br><a href="/2017/03/05/云南/3.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/3.jpg" title="云南图片"></a><br><a href="/2017/03/05/云南/13.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/13.jpg" title="云南图片"></a></p><p>泸沽湖 | 西游记中的女儿国有无有<br><a href="/2017/03/05/云南/4.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/4.jpg" title="云南图片"></a><br><a href="/2017/03/05/云南/5.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/5.jpg" title="云南图片"></a><br><a href="/2017/03/05/云南/10.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/10.jpg" title="云南图片"></a></p><p>拉市海 | 骑马体验茶马古道然后在拉市海上划船<br><a href="/2017/03/05/云南/8.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/8.jpg" title="云南图片"></a></p><p>玉龙雪山 | 海拔太高略有高原反应<br><a href="/2017/03/05/云南/7.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/7.jpg" title="云南图片"></a></p><p>普达措 | 冷到你怀疑人生有无有<br><a href="/2017/03/05/云南/11.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/11.jpg" title="云南图片"></a><br><a href="/2017/03/05/云南/12.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/12.jpg" title="云南图片"></a><br><a href="/2017/03/05/云南/15.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/15.jpg" title="云南图片"></a></p><p>香格里拉 | 并没有觉得网上流传的感觉<br><a href="/2017/03/05/云南/14.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2017/03/05/云南/14.jpg" title="云南图片"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实我是不喜欢外出的人，但妻子就特别喜欢旅游，经不住她的软硬兼施，就选定了云南作为我们的蜜月旅游之地，虽然旅途很累，胜在提前妻子就攻略好，我负责拍摄就好了，下面是我拍的一些照片。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://linaicai.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="旅游" scheme="https://linaicai.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目架构小试牛刀</title>
    <link href="https://linaicai.github.io/2016/06/04/iOS%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>https://linaicai.github.io/2016/06/04/iOS项目架构小试牛刀/</id>
    <published>2016-06-04T14:42:21.000Z</published>
    <updated>2017-07-24T16:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近为公司一个iOS项目负责架构搭建和开发工作，所以关于架构方面参考了很多资料，最后选用MVVM的设计理念，然后发现现在使用MVVM应该是稍微大一点的项目的必备了吧。<br><a id="more"></a></p><h2 id="然后我想谈谈我对于架构的理解。"><a href="#然后我想谈谈我对于架构的理解。" class="headerlink" title="然后我想谈谈我对于架构的理解。"></a><strong>然后我想谈谈我对于架构的理解。</strong></h2><ul><li>为什么项目需要架构设计？</li></ul><p>iOS开发技术已经快10年，工程技术的应用积累已经达到一个里程碑，已经不能再用小打小闹来解决软件工程的各种问题，而大项目一般功能颇多，难度大，周期长，还需要维护，而开发人员又流动可能很快的情况下，怎么解决易用性和低成本维护，这里头需要架构设计。</p><ul><li>一般有哪些常用的架构，各种架构的优缺点又怎样？<br>常用的有万金油MVC，完全体MVP，超新星MVVM</li></ul><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近为公司一个iOS项目负责架构搭建和开发工作，所以关于架构方面参考了很多资料，最后选用MVVM的设计理念，然后发现现在使用MVVM应该是稍微大一点的项目的必备了吧。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://linaicai.github.io/categories/iOS/"/>
    
    
      <category term="架构" scheme="https://linaicai.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS生成二维码</title>
    <link href="https://linaicai.github.io/2016/06/04/iOS%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>https://linaicai.github.io/2016/06/04/iOS生成二维码/</id>
    <published>2016-06-04T13:38:05.000Z</published>
    <updated>2017-07-24T16:43:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>iOS7之后，可以使用原生的CIFilter创建二维码，下面是相应的代码，我整理到UIImage分类里面:<br><a id="more"></a><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">objectivec</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个二维码图片</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)createQRForString:(<span class="built_in">NSString</span> *)string withSize:(<span class="built_in">CGFloat</span>)size&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *stringData = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// 创建filter</span></span><br><span class="line">    <span class="built_in">CIFilter</span> *qrFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIQRCodeGenerator"</span>];</span><br><span class="line">    <span class="comment">// 设置内容和纠错级别</span></span><br><span class="line">    [qrFilter setValue:stringData forKey:<span class="string">@"inputMessage"</span>];</span><br><span class="line">    [qrFilter setValue:<span class="string">@"M"</span> forKey:<span class="string">@"inputCorrectionLevel"</span>];</span><br><span class="line">    <span class="comment">//导出CIImage</span></span><br><span class="line">    <span class="built_in">CIImage</span> *image = qrFilter.outputImage;</span><br><span class="line">    <span class="built_in">CGRect</span> extent = <span class="built_in">CGRectIntegral</span>(image.extent);</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MIN(size/<span class="built_in">CGRectGetWidth</span>(extent), size/<span class="built_in">CGRectGetHeight</span>(extent));</span><br><span class="line">    <span class="comment">// 1.创建bitmap;</span></span><br><span class="line">    size_t width = <span class="built_in">CGRectGetWidth</span>(extent) * scale;</span><br><span class="line">    size_t height = <span class="built_in">CGRectGetHeight</span>(extent) * scale;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cs = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> bitmapRef = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, cs, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNone);</span><br><span class="line">    <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CGImageRef</span> bitmapImage = [context createCGImage:image fromRect:extent];</span><br><span class="line">    <span class="built_in">CGContextSetInterpolationQuality</span>(bitmapRef, kCGInterpolationNone);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(bitmapRef, scale, scale);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(bitmapRef, extent, bitmapImage);</span><br><span class="line">    <span class="comment">// 2.保存bitmap到图片</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> scaledImage = <span class="built_in">CGBitmapContextCreateImage</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(bitmapImage);</span><br><span class="line">    <span class="comment">//原图</span></span><br><span class="line">    <span class="built_in">UIImage</span> *outputImage = [<span class="built_in">UIImage</span> imageWithCGImage:scaledImage];</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(outputImage.size, <span class="literal">NO</span>, [[<span class="built_in">UIScreen</span> mainScreen] scale]);</span><br><span class="line">    [outputImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span> , size, size)];</span><br><span class="line">    <span class="comment">//水印图</span></span><br><span class="line">    <span class="built_in">UIImage</span> *waterimage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"水印图"</span>];</span><br><span class="line">    [waterimage drawInRect:<span class="built_in">CGRectMake</span>((size-waterImagesize)/<span class="number">2.0</span>, (size-waterImagesize)/<span class="number">2.0</span>, waterImagesize, waterImagesize)];</span><br><span class="line">    <span class="built_in">UIImage</span> *newPic = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> newPic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p>PS:该方法传入的string是二维码的内容，size是二维码图片的大小，另外还可以设置二维码的水印图片，就是二维码中间那张小小的图片,waterImagesize是宏定义，定义水印图片的大小。</p><p>以上代码亲测可以!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS7之后，可以使用原生的CIFilter创建二维码，下面是相应的代码，我整理到UIImage分类里面:&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://linaicai.github.io/categories/iOS/"/>
    
    
      <category term="二维码" scheme="https://linaicai.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux日常管理(一)</title>
    <link href="https://linaicai.github.io/2016/04/16/Linux%E6%97%A5%E5%B8%B8%E7%AE%A1%E7%90%86-%E4%B8%80/"/>
    <id>https://linaicai.github.io/2016/04/16/Linux日常管理-一/</id>
    <published>2016-04-16T15:59:06.000Z</published>
    <updated>2017-07-24T16:42:59.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近有个虚拟主机快到期，打算使用Linode上新的VPS所以准备迁移到另一台香港VPS（和虚拟主机同一个代理商），结果发现无法SSH登录，然后打开网址也发现无法访问，SVN也没发刷新，PING却通了，可以肯定的是系统是正常运行的但几乎所有程序都启动不正常，提交了工单，客服回复我是系统卡死，对方帮我重启机器，我重新登录进去后启动SVN服务后发现又无法访问，最后经过客服确认内存溢出。</p><p>第一时间觉得卧槽我的CentOS几乎没怎么动过，一直都能正常运行啊，就算内存几乎爆满，也不至于溢出吧，于是使用<br><code>ps -A</code><br>命令看进程，发现除了一些系统服务进程，并没有可疑进程，不过我想删了一些明显没用到的和多余的总没错吧<br><a href="/2016/04/16/Linux日常管理-一/C2E57850-7519-433D-8B47-8B808F2790F8.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img src="/2016/04/16/Linux日常管理-一/C2E57850-7519-433D-8B47-8B808F2790F8.png" title="This is an example image"></a></p><a id="more"></a><p>其中，发现pptpd(已经全面转为使用SS代理)这个以前遗留下来的VPN服务进程，和一堆类似的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">awk</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/dev/</span>tty1</span><br><span class="line"><span class="regexp">/dev/</span>tty2</span><br><span class="line"><span class="regexp">/dev/</span>tty3</span><br><span class="line"><span class="regexp">/dev/</span>tty4</span><br><span class="line"><span class="regexp">/dev/</span>tty5</span><br><span class="line"><span class="regexp">/dev/</span>tty6</span><br></pre></td></tr></table></figure></div><p>查了资料才知道这东西是因为CentOS系统默认的6个打开的控制台，会驻留内存，于是准备删除多余的，下面就是过程步骤：</p><h3 id="删除pptpd"><a href="#删除pptpd" class="headerlink" title="删除pptpd"></a>删除pptpd</h3><p>由于这个服务是开机启动的，所以要先停止<br><code>service pptpd stop</code><br>然后<br><code>yum remove pptpd</code><br>完事</p><h3 id="删除多余的控制台进程"><a href="#删除多余的控制台进程" class="headerlink" title="删除多余的控制台进程"></a>删除多余的控制台进程</h3><p>首先找到TTY的配置文件编辑</p><p><code>vi /etc/init/start-ttys.conf</code></p><p>找到 tty [1-6] 改成 tty [1-2]，然后</p><p><code>vi /etc/sysconfig/init</code></p><p>找到</p><p><code>ACTIVE_CONSOLES=/dev/tty[1-6]</code></p><p>修改为</p><p><code>ACTIVE_CONSOLES=/dev/tty[1-2]</code></p><p>重启机器<code>reboot</code></p><p>最后，发现每次reboot后都需要重新启动svn服务，这是有多恶心啊，于是仿照网友的做法写了个启动脚本，让服务器每次启动时自动加载这个脚本来完成svn服务的开启，下面是过程：</p><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><p><code>vi /var/svn/svn_startup.sh</code></p><p>进入编辑模式，输入</p><p><code>#!/bin/bash/usr/bin/svnserve -d -r /var/svn/svnrepos</code></p><p>注意第二行前面部分是svnserve的安装路径，可以使用which svnserve查看到，后面是你的svn的repo的路径，/var/svn/svnrepos是我习惯的使用路径，我把脚本也放到/var/svn下了，方便管理。</p><h3 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h3><p>脚本需要添加权限才能正常运行，使用</p><p><code>chmod 777 /var/svn/svn_startup.sh</code></p><h3 id="加入开机自动运行"><a href="#加入开机自动运行" class="headerlink" title="加入开机自动运行"></a>加入开机自动运行</h3><p><code>vi /etc/rc.d/rc.local</code></p><p>在末尾添加脚本的路径</p><p><code>/var/svn/svn_startup.sh</code></p><p>保存并重启一下机器，然后验证一下svn服务是否自动启动</p><p><code>ps -ef|grep svnserve</code></p><p>最后，今天收获很大，不过还没有解决的问题是，CentOS上面httpd服务进程数有时候很多，有时候又很少，暂时猜测是apache的服务机制，收到一个http请求就会新建一个httpd进程来完成php脚本解析，后续会专门研究写关于Apache的文章。</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>其实最占内存的进程是mysqld，这个都知道是数据库的守护进程，而我发现mysql55w版本存在内存使用巨大，而mysql5.1.3版本的就没有这个问题，基于当前服务器上对数据库版本要求不大，所以更换了mysql5.1.3后，内存使用就正常了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;最近有个虚拟主机快到期，打算使用Linode上新的VPS所以准备迁移到另一台香港VPS（和虚拟主机同一个代理商），结果发现无法SSH登录，然后打开网址也发现无法访问，SVN也没发刷新，PING却通了，可以肯定的是系统是正常运行的但几乎所有程序都启动不正常，提交了工单，客服回复我是系统卡死，对方帮我重启机器，我重新登录进去后启动SVN服务后发现又无法访问，最后经过客服确认内存溢出。&lt;/p&gt;
&lt;p&gt;第一时间觉得卧槽我的CentOS几乎没怎么动过，一直都能正常运行啊，就算内存几乎爆满，也不至于溢出吧，于是使用&lt;br&gt;&lt;code&gt;ps -A&lt;/code&gt;&lt;br&gt;命令看进程，发现除了一些系统服务进程，并没有可疑进程，不过我想删了一些明显没用到的和多余的总没错吧&lt;br&gt;&lt;img src=&quot;/2016/04/16/Linux日常管理-一/C2E57850-7519-433D-8B47-8B808F2790F8.png&quot; title=&quot;This is an example image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://linaicai.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://linaicai.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>iOS 如何创建和使用静态库</title>
    <link href="https://linaicai.github.io/2016/03/13/iOS-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>https://linaicai.github.io/2016/03/13/iOS-如何创建和使用静态库/</id>
    <published>2016-03-12T17:05:12.000Z</published>
    <updated>2017-07-24T16:43:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文引用自<a href="http://blog.ibireme.com/2013/09/18/create-ios-static-framework/" target="_blank" rel="noopener">iOS 如何创建和使用静态库</a></p><p>iOS里可以用静态链接库和动态链接库，但由于Appstore的政策限制，上架应用只能用苹果提供的动态链接库，第三方的库只能做成静态库。这里介绍一下静态链接库的创建方法和常见的一些问题。</p><ol><li>最常见的方法就是Xcode自带的模板”Cocoa Touch Static Library”。这个很好理解，苹果自己有一个简单的教程，网上也有大把的说明。最终的结果就是一个.a文件和一堆.h头文件。用起来也相对简单：把头文件导入，关联.a静态库，就可以编译了。</li></ol><p>下面是一些示例：<a href="http://open.weibo.com/wiki/SDK#iOS_SDK" target="_blank" rel="noopener">新浪微博SDK</a>，<a href="http://open.weixin.qq.com/document/gettingstart/ios/?lang=zh_CN" target="_blank" rel="noopener">微信SDK</a>。</p> <a id="more"></a><p>2.通过一些方法，将静态库打包成.framework，虽然是静态库，但使用表现上比较接近系统的动态库。目前来看这种方法比第1种好一些，所以推荐用这种方法。手动创建一个静态.framework是非常繁琐的一件事情，详细的过程可以看这里或者这里(中文)。懒人们可以用这个已经做好的模板：<a href="https://github.com/kstenerud/iOS-Universal-Framework" target="_blank" rel="noopener">iOS-Universal-Framework</a>。制作好后，用起来也就非常简单了，把.framework拖到工程里面就好。</p><p>下面是一些示例：<a href="http://developer.baidu.com/wiki/index.php?title=docs/social/sdk" target="_blank" rel="noopener">百度分享SDK</a>，<a href="http://wiki.dev.renren.com/wiki/V2/sdk/objectivec_sdk" target="_blank" rel="noopener">人人网SDK</a>。</p><p>常见问题：<br>1.制作出的静态库只能用在真机，不能用在模拟器，或者相反。</p><p>这时就需要把不同的代码（armv7/armv7s/i386…）的代码合并为通用的静态库。如果用上面的iOS-Universal-Framework，它会自动用脚本帮你完成。</p><p>为了在build时创建支持多架构的代码，可以这样设置：在Xcode里面的Build Setting -&gt; Valid Architectures 里面，添加 armv7 armv7s arm64 i386 x86_64这几个类型； Build Setting -&gt; Build Active Architecture Only 选项设置为NO。</p><p>构建完成后，可以运行命令 lipo -info <file> 来查看静态库实际包含的架构，正常情况下，会显示类似这样的提示： Architectures in the fat file: <file> are: armv7 armv7s arm64 i386 x86_64。</file></file></p><p>(2014-09-11 update: 传言，从这天起提交AppStore的应用必须包含64位架构，所以提供SDK的人最好要确保库中包含arm64架构)</p><p>2.静态库里有Category方法，但是调用时报错“unrecognized selector send to instance.”等。</p><p>这个算是一个官方的已知bug，详情见苹果文档。简单点说，如果你写了一个静态库并且里面有Category，那你就需要让使用者在他们工程的编译参数”Other Linker Flags”里面添加 “-ObjC “选项。</p><p>另外，如果你写了一个.m文件，并且里面只有一个Category，这时就需要使用者添加”-all_load”来加载全部资源，或者添加”-force_load xxx”来强制加载你的库的资源。如果这么做会非常影响速度，为了修复这个问题，通常的解决办法是在这个.m文件里写一个空的Class来占位。下面是一个宏定义：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><figcaption><span>Use dummy class for category in static library.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DUMMY_CLASS</span><br><span class="line">#define DUMMY_CLASS(name) \</span><br><span class="line">    @interface DUMMY_CLASS_ ## name : NSObject @end \</span><br><span class="line">    @implementation DUMMY_CLASS_ ## name @end</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">//使用示例:</span><br><span class="line">//UIColor+YYAdd.m</span><br><span class="line">#import &quot;UIColor+YYAdd.h&quot;</span><br><span class="line">DUMMY_CLASS(UIColor+YYAdd)</span><br><span class="line"> </span><br><span class="line">@implementation UIColor(YYAdd)</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>3.添加了静态库后，编译报错”有重复定义的符号(duplicate symbol )”。</p><p>这通常是静态库中的某些定义和使用者的工程有冲突。由于ObjC没有命名空间或者包管理这样的东西，所以静态库的开发者一定要把静态库中的东西全部加上Prefix来做保护。例如，某个SDK用到了JSONKit，那就尽量把JSONKit里面的声明都加上前缀，例如XXXJSONDecoder。</p><p>如果你是在用到别人制作的库时遇到这个问题，并且那人没有提供源码，赶紧去联系那人让他改！！ 我所知度厂鹅厂啊，从网什么的都干过这事儿(尤其是鹅厂SDK)。。</p><p>其他注意事项：发布静态库时要注意选项”Release/Debug”。如果修改了静态库，但代码不起作用，一定要清除各种缓存和关联。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文引用自&lt;a href=&quot;http://blog.ibireme.com/2013/09/18/create-ios-static-framework/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS 如何创建和使用静态库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;iOS里可以用静态链接库和动态链接库，但由于Appstore的政策限制，上架应用只能用苹果提供的动态链接库，第三方的库只能做成静态库。这里介绍一下静态链接库的创建方法和常见的一些问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最常见的方法就是Xcode自带的模板”Cocoa Touch Static Library”。这个很好理解，苹果自己有一个简单的教程，网上也有大把的说明。最终的结果就是一个.a文件和一堆.h头文件。用起来也相对简单：把头文件导入，关联.a静态库，就可以编译了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一些示例：&lt;a href=&quot;http://open.weibo.com/wiki/SDK#iOS_SDK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新浪微博SDK&lt;/a&gt;，&lt;a href=&quot;http://open.weixin.qq.com/document/gettingstart/ios/?lang=zh_CN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信SDK&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://linaicai.github.io/categories/iOS/"/>
    
    
      <category term="静态库" scheme="https://linaicai.github.io/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发runtime之Method Swizzling</title>
    <link href="https://linaicai.github.io/2016/03/12/iOS%E5%BC%80%E5%8F%91runtime%E4%B9%8Bmethod/"/>
    <id>https://linaicai.github.io/2016/03/12/iOS开发runtime之method/</id>
    <published>2016-03-12T13:52:07.000Z</published>
    <updated>2017-07-24T16:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>1、理解Method Swizzling</strong></p><p>Method Swizzling 俗称黑魔法，实现原理是iOS的运行时runtime，实际上它是在运行时阶段交换了两个方法的函数指针，iOS应聘的很多时候面试官都喜欢问和关注的技术问题，我们需要对它有所了解，学会运用，因为他确实很强大，有些功能实现的时候使用它能够做到事半功倍。</p><p><strong>2、使用场景</strong><br>典型的应用场景有：数据、事件、页面统计，比如百度和友盟、谷歌的数据分析和统计。<br><a id="more"></a><br><strong>3、具体实现的方法（上代码）</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//  AppDelegate+test.h</span><br><span class="line">// </span><br><span class="line">//</span><br><span class="line">//  Created by LINAICAI on 16/3/12.</span><br><span class="line">//  Copyright © 2016年 LINAICAI. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">@interface AppDelegate (test)</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//  AppDelegate+test.m</span><br><span class="line">//  </span><br><span class="line">//</span><br><span class="line">//  Created by LINAICAI on 16/3/12.</span><br><span class="line">//  Copyright © 2016年 LINAICAI. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;AppDelegate+test.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation AppDelegate (test)</span><br><span class="line">+ (void)swizzleClassMethod:(Class)class originSelector:(SEL)originSelector otherSelector:(SEL)swizzledSelector&#123;</span><br><span class="line">    // the method might not exist in the class, but in its superclass</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(class, originSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">    </span><br><span class="line">    // class_addMethod will fail if original method already exists</span><br><span class="line">    BOOL didAddMethod = class_addMethod(class, originSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    </span><br><span class="line">    // the method doesn’t exist and we just added one</span><br><span class="line">    if (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        // When swizzling a class method, use the following:</span><br><span class="line">        // Class class = object_getClass((id)self);</span><br><span class="line">        [self swizzleClassMethod:class originSelector:@selector(application:didFinishLaunchingWithOptions:) otherSelector:@selector(swizzle_application:didFinishLaunchingWithOptions:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)swizzle_application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    //我们需要添加的代码</span><br><span class="line">    NSLog(@&quot;我是一段木马你信不信！！！&quot;);</span><br><span class="line">    return [self swizzle_application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>上述代码实现的就是hack了AppDelegate的代理application didFinishLaunchingWithOptions，其中我们可以插入自己想要插入的代码，同时由于在load阶段就已经完成这个过程，并不需要#import这个库的，所以乱用第三方库有风险！一定要分析和读懂别人的代码才使用，尤其lib或者framework的库，可以神不知鬼不觉的就插入了作恶的代码，其实很多知名企业的库就使用的这个技术，什么统计、分析之类的，在不了解代码或者不开源的情况下尽量使用大公司有信誉一点的会些。</p><p><strong>4、相关的库</strong><br>Github上搜下就能找到使用上述技术实现的库，特点是使用方便，功能犀利，代码少，这里列出部分库：<br><a href="https://github.com/RuiAAPeres/UIViewController-Swizzled" target="_blank" rel="noopener">UIViewController-Swizzled</a><br><a href="https://github.com/rabovik/RSSwizzle" target="_blank" rel="noopener">RSSwizzle</a><br><a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="noopener">jrswizzle</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1、理解Method Swizzling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Method Swizzling 俗称黑魔法，实现原理是iOS的运行时runtime，实际上它是在运行时阶段交换了两个方法的函数指针，iOS应聘的很多时候面试官都喜欢问和关注的技术问题，我们需要对它有所了解，学会运用，因为他确实很强大，有些功能实现的时候使用它能够做到事半功倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用场景&lt;/strong&gt;&lt;br&gt;典型的应用场景有：数据、事件、页面统计，比如百度和友盟、谷歌的数据分析和统计。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://linaicai.github.io/categories/iOS/"/>
    
    
      <category term="runtime" scheme="https://linaicai.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Linux下配置svn教程</title>
    <link href="https://linaicai.github.io/2015/11/12/Linux%E4%B8%8B%E9%85%8D%E7%BD%AEsvn%E6%95%99%E7%A8%8B/"/>
    <id>https://linaicai.github.io/2015/11/12/Linux下配置svn教程/</id>
    <published>2015-11-12T11:41:32.000Z</published>
    <updated>2019-02-21T08:32:51.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1、安装svn"><a href="#1、安装svn" class="headerlink" title="1、安装svn"></a>1、安装svn</h3><p>命令行下输入：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnserve --version</span><br></pre></td></tr></table></figure></div></p><p>确定是否已经安装过，如果没有安装，输入以下命令就可以开始安装<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install subversion</span><br></pre></td></tr></table></figure></div></p><p>下面一路yes，如果安装需要权限，命令前加上sudo即可</p><h3 id="2、新建仓库"><a href="#2、新建仓库" class="headerlink" title="2、新建仓库"></a>2、新建仓库</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/svn/repos</span><br><span class="line">svnadmin create /var/svn/repos</span><br></pre></td></tr></table></figure></div><p>上面两行命令，是新建了一个仓库，放在/var/svn/repos下，执行后可以cd到/var/svn/repos执行ls，就可以看到conf, db,format,hooks, locks, README.txt等文件和目录</p><a id="more"></a><h3 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h3><p>cd到conf下 ls 可以看到三个文件：passwd，authz，svnserve.conf,这里是关键<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi passwd</span><br></pre></td></tr></table></figure></div></p><p>新建用户和密码<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line"><span class="comment"># harry = harryssecret</span></span><br><span class="line"><span class="comment"># sally = sallyssecret</span></span><br><span class="line"><span class="built_in">test</span>=test123456</span><br></pre></td></tr></table></figure></div></p><p>即 用户名=密码 的格式 上面新建一个test用户密码为test123456<br>另外vi passwd后按i就是插入，编辑完后按esc然后:输入wq!可以保存后退出<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi authz</span><br></pre></td></tr></table></figure></div></p><p>为用户添加读写权限<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/]</span><br><span class="line"><span class="built_in">test</span>=rw</span><br></pre></td></tr></table></figure></div></p><p>最后记得保存wq!<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi svnserve.conf</span><br></pre></td></tr></table></figure></div></p><p>这里可以修改这个仓库的一些设置<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">anon-access = none <span class="comment"># 使非授权用户无法访问</span></span><br><span class="line">auth-access = write <span class="comment"># 使授权用户有写权限</span></span><br><span class="line">password-db = passwd</span><br><span class="line">authz-db = authz   <span class="comment"># 访问控制文件</span></span><br><span class="line">realm = /var/svn/repos <span class="comment"># 认证命名空间，subversion会在认证提示里显示，并且作为凭证缓存的关键字。</span></span><br></pre></td></tr></table></figure></div></p><p>svnserve.conf主要修改三个地方:password-db = password,authz-db = authz,realm = /var/svn/repos对应前面的配置<br>auth-access = write和anon-access = none看你需要</p><h3 id="4、启动svn服务"><a href="#4、启动svn服务" class="headerlink" title="4、启动svn服务"></a>4、启动svn服务</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r /var/svn/repos</span><br></pre></td></tr></table></figure></div><p>这样svn就以默认端口启动一个服务，如果后台以及ing有svn在运行，可以换一个端口如：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r /var/svn/repos --listen-port 3391</span><br><span class="line">svnserve -d -r /var/svn/repos --listen-port 9999</span><br></pre></td></tr></table></figure></div></p><p>但是，但是，但是小心防火墙禁止了对应的端口,想知道svn在对应的端口有没有启动服务，可以执行<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep svn|grep -v grep</span><br></pre></td></tr></table></figure></div></p><p>结果列出所有的svn服务进程，并且知道对应的svn仓库目录对应着监听什么端口<br>开启了防火墙，想用的端口如果被禁止了，例如3690端口被防火墙禁止了，可以修改防火墙<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3690 -j ACCEPT</span><br></pre></td></tr></table></figure></div></p><p>保存后重启：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、安装svn&quot;&gt;&lt;a href=&quot;#1、安装svn&quot; class=&quot;headerlink&quot; title=&quot;1、安装svn&quot;&gt;&lt;/a&gt;1、安装svn&lt;/h3&gt;&lt;p&gt;命令行下输入：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svnserve --version&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确定是否已经安装过，如果没有安装，输入以下命令就可以开始安装&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt install subversion&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下面一路yes，如果安装需要权限，命令前加上sudo即可&lt;/p&gt;
&lt;h3 id=&quot;2、新建仓库&quot;&gt;&lt;a href=&quot;#2、新建仓库&quot; class=&quot;headerlink&quot; title=&quot;2、新建仓库&quot;&gt;&lt;/a&gt;2、新建仓库&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir /var/svn/repos&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svnadmin create /var/svn/repos&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面两行命令，是新建了一个仓库，放在/var/svn/repos下，执行后可以cd到/var/svn/repos执行ls，就可以看到conf, db,format,hooks, locks, README.txt等文件和目录&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://linaicai.github.io/categories/Linux/"/>
    
    
      <category term="SVN" scheme="https://linaicai.github.io/tags/SVN/"/>
    
  </entry>
  
</feed>
